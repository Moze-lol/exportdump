#include "dump_writer.hpp"
#include "windows_exception.hpp"
#include <algorithm>
#include <cassert>
#include <memory>
#include <Windows.h>

IDumpWriter::IDumpWriter(const std::filesystem::path& path) :
	m_path(std::filesystem::absolute(path)),
	m_file(CreateFileW(m_path.wstring().c_str(), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, 0, nullptr)),
	m_writeBuffer(),
	m_writeBufferOffset()
{
	if (m_file == INVALID_HANDLE_VALUE)
	{
		throw WindowsException("Could not write export dump (CreateFile)");
	}

	DWORD sectorsPerCluster = 0;
	DWORD bytesPerSector = 0;

	if (!GetDiskFreeSpaceW(m_path.root_path().wstring().c_str(), &sectorsPerCluster, &bytesPerSector, nullptr, nullptr))
	{
		throw WindowsException("Failed to write export dump (GetDiskFreeSpace)");
	}

	m_writeBufferSize = sectorsPerCluster * bytesPerSector;
	m_writeBuffer = new std::byte[m_writeBufferSize];
}

IDumpWriter::~IDumpWriter()
{
	assert(!m_writeBufferOffset);
	CloseHandle(m_file);
	delete[] m_writeBuffer;
}

void IDumpWriter::flush()
{
	if (!WriteFile(m_file, m_writeBuffer, m_writeBufferOffset, nullptr, nullptr))
	{
		throw WindowsException("Failed to write export dump (WriteFile)");
	}

	m_writeBufferOffset = 0;
}


void IDumpWriter::write(std::span<const std::byte> buffer)
{
	size_t bytesToWrite = buffer.size_bytes();
	size_t bytesWritten = 0;

	do
	{
		size_t toWrite = std::min(buffer.size_bytes(), m_writeBufferSize - m_writeBufferOffset);
		std::memcpy(m_writeBuffer + m_writeBufferOffset, buffer.data(), toWrite);
		bytesWritten += toWrite;
		m_writeBufferOffset += toWrite;
		buffer = buffer.subspan(toWrite, buffer.size() - toWrite);

		if (m_writeBufferOffset >= m_writeBufferSize)
		{
			flush();
		}
	} while (bytesWritten < bytesToWrite);
}

void TXTDumpWriter::dumpExportsImpl(const PEFile& peFile, const Demangler& demangler)
{
	for (auto&& entry : peFile)
	{
		writeln("{} 0x{:X} {} {}", entry.ordinal, entry.address, entry.name, demangler.demangle(entry.name));
	}
}

void CPPDumpWriter::dumpExportsImpl(const PEFile& peFile, const Demangler& demangler)
{
	writeln("//Export dump for file \"{}\"", std::filesystem::absolute(peFile.path()).string());
	writeln("//THIS FILE IS AUTOGENERATED. DO NOT MODIFY!\n");

	writeln(R"(#pragma once
#include <cassert>
#include <cstdint>
#include <string>
#include <string_view>
)");

	auto peFilePath = peFile.path().filename();

	while (peFilePath.has_extension())
	{
		peFilePath = peFilePath.stem();
	}

	std::string peName = peFilePath.string();
	std::for_each(peName.begin(), peName.end(), [](char& c) { c = std::tolower(c); });
	writeln("namespace exports::{}", peName);
	writeln(R"({
	struct ExportData
	{
		const std::string_view name;
		const std::string_view demangledName;
		const uintptr_t address;
		const uint16_t ordinal;
	};

	inline constexpr ExportData g_exports[]{)");

	for (auto&& entry : peFile)
	{
		writeln("\t\t{{ \"{}\", \"{}\", 0x{:X}, {} }},", entry.name, demangler.demangle(entry.name), entry.address, entry.ordinal);
	}

	writeln(R"(};
	
	inline constexpr const size_t g_count = sizeof(g_exports) / sizeof(ExportData);

	template<typename Predicate>
	inline constexpr const ExportData* find(Predicate p)
	{
		return std::find_if(g_exports, g_exports + g_count, p);
	}

	inline constexpr const ExportData* findName(std::string_view name) { return find([name](const auto& e) {return e.name == name; }); }
	inline constexpr const ExportData* findDemangledName(std::string_view demangled) { return find([demangled](const auto& e) {return e.demangledName == demangled; }); }
	inline constexpr const ExportData* findAddress(uintptr_t address) { return find([address](const auto& e) {return e.address == address; }); }
	inline constexpr const ExportData* findOrdinal(uint16_t ordinal) { return find([ordinal](const auto& e) {return e.ordinal == ordinal; }); }
})");
}

void JSONDumpWriter::dumpExportsImpl(const PEFile& peFile, const Demangler& demangler)
{
	write(R"({
	"exports": [
)"); 

	//I would have loved the address field to be a hex number, but JSON does not support that. Web devs amiright?
	constexpr auto jsonObjFormat = R"({{ "ordinal": {}, "address": {},  "name": "{}", "demangledName": "{}" }})"; 

	//Since JSON is a lovely format that does not allow trailing commas in array entries, we print the first entry and then prepend commas to every other one
	EATEntry entry = peFile.EATEntryAt(0);
	write("\t\t");
	write(jsonObjFormat, entry.ordinal, entry.address, entry.name, demangler.demangle(entry.name));

	for (DWORD i = 1; i < peFile.EATEntryCount(); ++i)
	{
		EATEntry entry = peFile.EATEntryAt(i); //We actually have to redefine the variable, because a struct full of const members cant be copy-assigned
		write(R"(,
		)");
		write(jsonObjFormat, entry.ordinal, entry.address, entry.name, demangler.demangle(entry.name));
	}

	write(R"(
	]
})");
}
